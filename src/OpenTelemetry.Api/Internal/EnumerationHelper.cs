// <auto-generated>
// <copyright file="EnumerationHelper.cs" company="OpenTelemetry Authors">
// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// </copyright>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;

namespace OpenTelemetry.Internal
{
    internal class DictionaryEnumerator<TKey, TValue, TState> : Enumerator
        <IEnumerable<KeyValuePair<TKey, TValue>>,
        KeyValuePair<TKey, TValue>,
        TState>
        where TState : struct
    {
        protected DictionaryEnumerator()
        {
        }
    }

    internal class ListEnumerator<TValue, TState> : Enumerator
        <IEnumerable<TValue>,
        TValue,
        TState>
        where TState : struct
    {
        protected ListEnumerator()
        {
        }
    }

    // A helper class for enumerating over IEnumerable<TItem> without allocation if a struct enumerator is available.
    internal class Enumerator<TEnumerable, TItem, TState>
        where TEnumerable : IEnumerable<TItem>
        where TState : struct
    {
        private static readonly MethodInfo GenericGetEnumeratorMethod = typeof(IEnumerable<TItem>).GetMethod("GetEnumerator");
        private static readonly MethodInfo GeneircCurrentGetMethod = typeof(IEnumerator<TItem>).GetProperty("Current").GetMethod;
        private static readonly MethodInfo MoveNextMethod = typeof(IEnumerator).GetMethod("MoveNext");
        private static readonly MethodInfo DisposeMethod = typeof(IDisposable).GetMethod("Dispose");

        public delegate void AllocationFreeForEachDelegate(TEnumerable instance, ref TState state, ForEachDelegate itemCallback);

        public delegate bool ForEachDelegate(ref TState state, TItem item);

        protected Enumerator()
        {
        }

        /* We want to do this type of logic...
            public static void AllocationFreeForEach(Dictionary<string, int> dictionary, ref TState state, ForEachDelegate itemCallback)
            {
                using (Dictionary<string, int>.Enumerator enumerator = dictionary.GetEnumerator())
                {
                    while (enumerator.MoveNext())
                    {
                        if (!itemCallback(ref state, enumerator.Current))
                            break;
                    }
                }
            }
            ...because it takes advantage of the struct Enumerator on the built-in types which give an allocation-free way to enumerate.
        */
        public static AllocationFreeForEachDelegate BuildAllocationFreeForEachDelegate(Type enumerableType)
        {
            var itemCallbackType = typeof(ForEachDelegate);

            var dynamicMethod = new DynamicMethod(
                nameof(AllocationFreeForEachDelegate),
                null,
                new[] { typeof(TEnumerable), typeof(TState).MakeByRefType(), itemCallbackType },
                typeof(AllocationFreeForEachDelegate).Module,
                skipVisibility: true);

            var generator = dynamicMethod.GetILGenerator();

            var beginLoopLabel = generator.DefineLabel();
            var processCurrentLabel = generator.DefineLabel();
            var returnLabel = generator.DefineLabel();

            generator.Emit(OpCodes.Ldarg_0);
            var enumeratorType = EmitGetEnumerator(generator, enumerableType);
            generator.Emit(OpCodes.Stloc_0);

            generator.DeclareLocal(enumeratorType);
            bool isDisposable = typeof(IDisposable).IsAssignableFrom(enumeratorType);

            if (isDisposable)
            {
                // try
                generator.BeginExceptionBlock();
            }

            generator.Emit(OpCodes.Br_S, beginLoopLabel);

            generator.MarkLabel(processCurrentLabel);

            generator.Emit(OpCodes.Ldarg_2);
            generator.Emit(OpCodes.Ldarg_1);
            generator.Emit(OpCodes.Ldloca_S, 0);
            EmitGetCurrent(generator, enumeratorType);

            generator.Emit(OpCodes.Call, itemCallbackType.GetMethod("Invoke"));

            generator.Emit(OpCodes.Brtrue_S, beginLoopLabel);

            generator.Emit(OpCodes.Leave_S, returnLabel);

            generator.MarkLabel(beginLoopLabel);

            generator.Emit(OpCodes.Ldloca_S, 0);
            EmitMoveNext(generator, enumeratorType);

            generator.Emit(OpCodes.Brtrue_S, processCurrentLabel);

            if (isDisposable)
            {
                generator.Emit(OpCodes.Leave_S, returnLabel);

                // finally
                generator.BeginFinallyBlock();

                generator.Emit(OpCodes.Ldloca_S, 0);
                EmitDispose(generator, enumeratorType);

                generator.EndExceptionBlock();
            }

            generator.MarkLabel(returnLabel);

            generator.Emit(OpCodes.Ret);

            return (AllocationFreeForEachDelegate)dynamicMethod.CreateDelegate(typeof(AllocationFreeForEachDelegate));
        }

        private static Type EmitGetEnumerator(ILGenerator generator, Type enumerableType)
        {
            var getEnumeratorMethod = ResolveGetEnumeratorMethodForType(enumerableType);
            if (getEnumeratorMethod != null)
            {
                if (getEnumeratorMethod.IsVirtual && !getEnumeratorMethod.IsFinal)
                {
                    Debug.Fail("Performance regression virtual invocation.");
                    generator.Emit(OpCodes.Callvirt, getEnumeratorMethod);
                }
                else
                {
                    generator.Emit(OpCodes.Call, getEnumeratorMethod);
                }
                return getEnumeratorMethod.ReturnType;
            }

            // Fallback to allocation mode and use IEnumerable<TItem>.GetEnumerator.
            // Primarily for Array.Empty and Enumerable.Empty case, but also for user types.
            Debug.Fail("Performance regression virtual invocation.");
            generator.Emit(OpCodes.Constrained, typeof(IEnumerable<TItem>));
            generator.Emit(OpCodes.Callvirt, GenericGetEnumeratorMethod);

            return GenericGetEnumeratorMethod.ReturnType;
        }

        private static void EmitGetCurrent(ILGenerator generator, Type enumeratorType)
        {
            var getCurrentMethod = ResolveCurrentPropertyGetMethodForType(enumeratorType, typeof(TItem));
            if (getCurrentMethod != null)
            {
                if (getCurrentMethod.IsVirtual && !getCurrentMethod.IsFinal)
                {
                    Debug.Fail("Performance regression virtual invocation.");
                    generator.Emit(OpCodes.Callvirt, getCurrentMethod);
                }
                else
                {
                    generator.Emit(OpCodes.Call, getCurrentMethod);
                }
                return;
            }

            // Fallback to IEnumerator<TItem>.Current.
            Debug.Fail("Performance regression virtual invocation.");
            generator.Emit(OpCodes.Constrained, typeof(IEnumerator<TItem>));
            generator.Emit(OpCodes.Callvirt, GeneircCurrentGetMethod);
        }

        private static void EmitMoveNext(ILGenerator generator, Type enumeratorType)
        {
            var moveNextMethod = ResolveMoveNextMethodForType(enumeratorType);
            if (moveNextMethod != null)
            {
                if (moveNextMethod.IsVirtual && !moveNextMethod.IsFinal)
                {
                    Debug.Fail("Performance regression virtual invocation.");
                    generator.Emit(OpCodes.Callvirt, moveNextMethod);
                }
                else
                {
                    generator.Emit(OpCodes.Call, moveNextMethod);
                }
                return;
            }

            // Fallback to IEnumerator.MoveNext.
            Debug.Fail("Performance regression virtual invocation.");
            generator.Emit(OpCodes.Constrained, typeof(IEnumerator));
            generator.Emit(OpCodes.Callvirt, MoveNextMethod);
        }

        private static void EmitDispose(ILGenerator generator, Type enumeratorType)
        {
            var disposeMethod = ResolveDisposeMethodForType(enumeratorType);
            if (disposeMethod != null)
            {
                if (disposeMethod.IsVirtual && !disposeMethod.IsFinal)
                {
                    Debug.Fail("Performance regression virtual invocation.");
                    generator.Emit(OpCodes.Callvirt, disposeMethod);
                }
                else
                {
                    generator.Emit(OpCodes.Call, disposeMethod);
                }
                return;
            }

            // Fallback to IDisposable.Dispose.
            Debug.Fail("Performance regression virtual invocation.");
            generator.Emit(OpCodes.Constrained, typeof(IDisposable));
            generator.Emit(OpCodes.Callvirt, DisposeMethod);
        }

        private static MethodInfo ResolveGetEnumeratorMethodForType(Type type)
        {
            var methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            foreach (var method in methods)
            {
                if (method.Name == "GetEnumerator" && !method.ReturnType.IsInterface)
                {
                    return method;
                }
            }

            return null;
        }

        private static MethodInfo ResolveCurrentPropertyGetMethodForType(Type enumeratorType, Type itemType)
        {
            PropertyInfo[] properties = enumeratorType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            foreach (PropertyInfo property in properties)
            {
                if (property.Name == "Current"
                    && property.CanRead
                    && property.PropertyType == itemType)
                {
                    return property.GetMethod;
                }
            }

            return null;
        }

        private static MethodInfo ResolveMoveNextMethodForType(Type type)
        {
            var methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            foreach (var method in methods)
            {
                if (method.Name == "MoveNext")
                {
                    return method;
                }
            }

            return null;
        }

        private static MethodInfo ResolveDisposeMethodForType(Type type)
        {
            var methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            foreach (var method in methods)
            {
                if (method.Name == "Dispose")
                {
                    return method;
                }
            }

            return null;
        }
    }
}
